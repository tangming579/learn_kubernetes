## 概述

Kubernetes 是一个可移植、可扩展的开源平台，用于管理容器化的工作负载和服务，可促进声明式配置和自动化。

### 主要功能

- 服务发现和负载均衡：DNS 或 IP 实现服务发现，负载均衡分配网络流量
- 存储编排：自动挂载选择的存储系统，包括本次存储，公共云。
- 自动部署和回滚：自动化容器创建、状态控制
- 自动完成装箱计算：允许指定每个容器所需 CPU 和内存
- 自我修复：重启失败的容器、替换容器、杀死不响应的容器
- 秘钥与配置管理：允许存储和管理敏感信息，例如密码、OAuth 令牌和 ssh 密钥

### Kubernetes 组件

#### Control Plane Components

控制平面组件对集群做出全局决策（比如调度），以及检测和响应集群事件

- kube-apiserver： 该组件公开了 Kubernetes API，是 Kubernetes 控制面的前端。它可通过部署多个实例进行伸缩。
- etcd：兼具一致性和高可用性的键值数据库，可以作为保存 Kubernetes 所有集群数据的后台数据库。
- kube-scheduler：负责监视新创建的、未指定运行节点（node）的 Pods，选择节点让 Pod 在上面运行。
- kube-controller-manager：运行控制器进程的控制平面组件。包括：
  - 节点控制器（Node Controller）：负责在节点出现故障时进行通知和响应
  - 任务控制器（Job controller）：监测代表一次性任务的 Job 对象，然后创建 Pods 来运行这些任务直至完成
  - 端点控制器（Endpoints Controller）：填充端点（Endpoints）对象（即加入 Service 与 Pod）
  - 服务帐户和令牌控制器（Service Account & Token Controllers）：为新的命名空间创建默认帐户和 API 访问令牌
- cloud-controller-manager：云控制器管理器，集群连接到云提供商的 API 之上。包括：
  - 节点控制器（Node Controller）：用于在节点终止响应后检查云提供商以确定节点是否已被删除
  - 路由控制器（Route Controller）：用于在底层云基础架构中设置路由
  - 服务控制器（Service Controller）：用于创建、更新和删除云提供商负载均衡器

#### Node 组件

维护运行的 Pod 并提供 Kubernetes 运行环境

- kubelet：集群中每个节点（node）上运行的代理。 它保证容器（containers）都 运行在 Pod 中。
- kube-proxy：集群中每个节点上运行的网络代理，允许从集群内部或外部的网络会话与 Pod 进行网络通信。
- 容器运行时（Container Runtime）：负责运行容器的软件，例如 Docker、 containerd、CRI-O 以及 Kubernetes CRI (容器运行环境接口) 的其他任何实现。

#### 插件（Addons）

- DNS ：必备插件， 为 Kubernetes 服务提供 DNS 记录。
- Web 界面（仪表盘）：管理集群中运行的应用程序以及集群本身并进行故障排除
- 容器资源监控：负责将集群资源状态、节点状态等保存到集中的数据库中，并提供浏览界面。
- 集群层面日志：负责将容器的日志数据 保存到一个集中的日志存储中，该存储能够提供搜索和浏览接口。

### Kubernetes API

Kubernetes 控制面的核心是 API 服务器。 API 服务器负责提供 HTTP API，以供用户、集群中的不同部分和集群外部组件相互通信。

大部分操作都可以通过 kubectl 命令行接口或 类似 kubeadm 这类命令行工具来执行， 这些工具在背后也是调用 Rest API。

- 各个语言 API 类库： [客户端库](https://kubernetes.io/zh/docs/reference/using-api/client-libraries/)
- Open API 规范： [OpenAPI](https://www.openapis.org/)

### Kubernetes Objects

Kubernetes 对象是持久化的实体， Kubernetes 使用这些实体去表示整个集群的状态，操作 Kubernetes 对象需要使用 Kubernetes API

几乎每个Kubernetes 对象包含两个嵌套的对象字段：

- `spec`（规约）：创建对象时设置其内容，描述你希望对象所具有的特征： *期望状态（Desired State）* 。
- `status`（状态）：描述了对象的 *当前状态（Current State）*

Kubernetes 控制平面都一直积极地管理着对象的实际状态，以使之与期望状态相匹配

#### 描述 Kubernetes 对象

创建 Kubernetes 对象时，必须提供对象的规约，用来描述该对象的期望状态，以下为在 .yaml 文件中提供信息的示例：

``` yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  selector:
    matchLabels:
      app: nginx
  replicas: 2 # tells deployment to run 2 pods matching the template
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.14.2
        ports:
        - containerPort: 80
```

**必需字段** 

- `apiVersion` - 创建该对象所使用的 Kubernetes API 的版本
- `kind` - 想要创建的对象的类别
- `metadata` - 唯一性标识对象
- `spec` - 期望的该对象的状态

#### Kubernetes 对象管理

`kubectl` 命令行工具支持3种不同的方式来创建和管理 Kubernetes 对象：

| 管理技术       | 作用于   | 建议的环境 | 特点                                                         |
| -------------- | -------- | ---------- | ------------------------------------------------------------ |
| 指令式命令     | 活跃对象 | 开发项目   | 命令简单，不具备变更审查、审核跟踪功能，不提供用于创建新对象的模板 |
| 指令式对象配置 | 单个文件 | 生产项目   | 可以版本管理、与流程集成；更适合文件，而非目录；对活动对象的更新必须反映在配置文件中 |
| 声明式对象配置 | 文件目录 | 生产项目   | 更改即使未合并到配置文件中，也会被保留下来；操作复杂，有时难于理解 |

#### 对象名称和 IDs

名称：标识同类资源中的唯一性；ID：标识整个集群中的唯一性

**名称**

客户端提供的字符串，引用资源 url 中的对象，如`/api/v1/pods/some name`

> 如果在 Node 对象未被删除并重建的条件下，重新创建了同名的物理主机， 则 Kubernetes 会将新的主机看作是老的主机，这可能会带来某种不一致性。

**UIDs**

Kubernetes 系统生成的字符串，唯一标识对象。

